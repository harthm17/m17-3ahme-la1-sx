# Protokoll
--------------------------------------------------------------------------------------------------------------------------
* **Thema:** Mark Down-GitHub
* **Datum:** 06.10.2019
* **Gefehlt:**---
* **Erstellt von:** WADE Kilian
* **Protokoll letzte Einheit:** 
* **Protokoll nächste Einheit**
-----------------------------------------------------------------------------------------------------------------------------
# Inhaltsverzeichnis
1. [Was ist Mark Down überhaupt?](#was-ist-mark-down-überhaupt?)
2. [Github](#github)
   1. [Erste Kommandos](#erste-kommandos)
   1. [Überschriften](#überschriften)
   1. [Listen Aufzählungen](#listen-aufzählungen)
       * [* * * * ----> Simple Punkte](#*_*_*_*_---->_simple_punkte) 
       * [1._2._3._4.----> Nummerierte Aufzählung](#1._2._3._4.---->_nummerierte_aufzählung) 
       * [1._1._1._1._1.---->Automatisch Nummerierte Aufzählung](#1._1._1._1._1.---->automatisch_nummerierte_aufzählung)
3. [Simple Textbearbeitung](#simple_textbearbeitung)
    * [Fett](#fett)
    * [Kursiv](#kursiv)
    * [Durchgestrichen](#durchgestrichen)
4. [ProgrammierCode](#programmiercode)
5. [Git](#git)




# Was ist Mark Down überhaupt?
Als erstes sprachen wir mit Herr Professor Steiner darüber wie mann überhaupt Daten sammeln bzw speichern kann. Dies ist schriftlich in Form einer Mitschrift möglich das ist die Einfachste und schnellste Möglichkeit. Dennoch ist sie nicht die schönste Art und könnte unlesbar werden. Dann besprachen wir kurz die Textverarbeitung welche viele unzählige Möglichkeiten bietet text zu verarbeiten und bearbeiten also für Informationsaustausch ungeeignet. Mark Down jedoch liegt genau zwischen Papier und Textverarbeitung und bietet eine sichere und schlichte art Information zu dokumentiern und weitergeben.

Papier<--Mark Down-->Textverarbeitung


# GitHub
## Erste Kommandos
### Überschriften:
                                   
                                  * 1x #------->h1
                                   
                                  * 2x ##------>h2
                                   
                                  * 3x ###----->h3
                                  
                                  * 4x ####---->h4
                                   
                                  * 5x #####--->h5
                                   
                                  * #6x ######-->h6

### Listen Aufzählungen
#### * * * * ----> Simple Punkte 
---
* Beispiel
* Beispiel
* Beispiel
---
#### 1._2._3._4.----> Nummerierte Aufzählung
---
1. Beispiel
2. Beispiel
3. Beispiel
---
#### 1._1._1._1._1.---->Automatisch Nummerierte Aufzählung
---

1. Beispiel
1. Beispiel
1. Beispiel

---
# Simple Textbearbeitung

## Fett
-> ** Fett**
---

**Beispiel**

---
## Kursiv
-> * Kursiv *
---

*Beispiel*

---
## Durchgestrichen
-> ~ Durchgestrichen ~
---
~Beispiel~
---
# ProgrammierCode
 ---    
 ```bash
    int main () 
    {
    printf("Hallo WELT!!!!!");
    return 0;
    }
```
---
# Git

![Git Daten][Git Daten]
https://www.patrickzahnd.ch/uploads/git-transport-v1.png

## Remote Repository--> Repository am Server nicht ~Lokal~

```git add```---> Änderung am Arbeitsverzeichnis

```git commit```---> Erfassung eines gewissen Bereiches

```git reset```---> Löschen aller letzten Änderungen

```git reset--hard```---> Löschen aller nicht gespeicherten Änderungen

```git status```---> Abfragen des Status

```git push```---> Hochladen vom lokalen repository in das remote repository


## Stash
--> Alte Versionen der Datei 

## Workplace
--> Arbeitsplatz alle repositories gespeichert

## Index
--> Nächstes commited datei gespeichert


## Local Repository 
--> Lokalen Änderungen am eigenen Rechner 

# Shell Kommandos
![Shell Kommando][Shell Kommando]
https://miro.medium.com/max/722/1*as8xYJog3ibGmjWB11sOvg.png
------------------
1. Clear: Eingabe-Fenster aufräumen
2. Whoami - wer bin ich - und Who
3. pwd: Wo bin ich?
4. df: Dateisystem und Speicherplatz anzeigen
5. Passwd: Passwort ändern
6. ls: Verzeichnis anzeigen
7. cd: Verzeichnis wechseln
8. cp: Kopieren und umbenennen
9. rm: Dateien löschen
10. Cat: Schnell eine Textdatei anzeigen oder erstellen
11. Quelle--->[Shell-Kommando2]https://www.pcwelt.de/ratgeber/Die_10_wichtigsten_Linux-Befehle_fuer_Einsteiger-Kommandozeile_alias_Terminal-8858519.html
-------------------------------------------
# Was ist ein Branch?
![Branch][Branch]
Quelle--->https://www.patrickzahnd.ch/uploads/gitflow.png

Um wirklich zu verstehen, wie Git Branching durchführt, müssen wir einen Schritt zurück gehen und untersuchen, wie Git die Daten speichert. Wie Du Dich vielleicht noch an Kapitel 1 erinnerst, speichert Git seine Daten nicht als Serie von Änderungen oder Unterschieden, sondern als Serie von Schnappschüssen.Wenn Du in Git committest, speichert Git ein sogenanntes Commit-Objekt. Dieses enthält einen Zeiger zu dem Schnappschuss mit den Objekten der Staging-Area, dem Autor, den Commit-Metadaten und einem Zeiger zu den direkten Eltern des Commits. Ein initialer Commit hat keine Eltern-Commits, ein normaler Commit stammt von einem Eltern-Commit ab und ein Merge-Commit, welcher aus einer Zusammenführung von zwei oder mehr Branches resultiert, besitzt ebenso viele Eltern-Commits.Um das zu verdeutlichen, lass uns annehmen, Du hast ein Verzeichnis mit drei Dateien, die Du alle zu der Staging-Area hinzufügst und in einem Commit verpackst. Durch das Stagen der Dateien erzeugt Git für jede Datei eine Prüfsumme (der SHA-1 Hash, den wir in Kapitel 1 erwähnt haben), speichert diese Version der Datei im Git-Repository (Git referenziert auf diese als Blobs) und fügt die Prüfsumme der Staging-Area hinzu:

```$ git add README test.rb LICENSE```
```$ git commit -m 'initial commit of my project'```
Quelle--->https://git-scm.com/book/de/v1/Git-Branching-Was-ist-ein-Branch%3F

--------------------------------------
# Was ist ein Merge 
Die Grundlagen des Zusammenführens (Mergen)

Angenommen, Du hast entschieden, dass Deine Arbeiten an issue #53 abgeschlossen sind und das Ganze soweit ist, dass es mit dem master Branch zusammengeführt werden kann. Um das zu erreichen, wirst Du Deinen iss53 Branch in den master Branch einfließen lassen, genauso wie Du es mit dem hotfix Branch zuvor getan hast. Du musst nur mit der Anweisung checkout zum dem Branch zu wechseln, in welchen Du etwas einfließen lassen möchtest und dann die Anweisung git merge ausführen:
```
$ git checkout master
$ git merge iss53
Auto-merging README
Merge made by the 'recursive' strategy.
 README | 1 +
 1 file changed, 1 insertion(+)
```
Das sieht ein bisschen anders aus als das hotfix merge von vorhin. Hier haben sich die Entwicklungsstränge schon zu einem früheren Zeitpunkt geteilt. Da der commit auf dem Branch, in dem Du Dich befindest, kein direkter Nachfolger von dem Branch ist, in den Du das merge machst, hat Git einiges zu tun. Dazu macht Git einen 3-Wege merge, wobei es die beiden Schnappschüsse verwendet, welche auf die Enden der Branches zeigen, und den gemeinsamen Vorfahren dieser beiden.Die Abbildung zeigt die drei snapshots(IN ROT), die Git in diesem Fall für das merge verwendet.
![Merge][Merge]https://git-scm.com/figures/18333fig0316-tn.png


[Shell Kommando]: https://miro.medium.com/max/722/1*as8xYJog3ibGmjWB11sOvg.png
[Shell-Kommando2]: https://www.pcwelt.de/ratgeber/Die_10_wichtigsten_Linux-Befehle_fuer_Einsteiger-Kommandozeile_alias_Terminal-8858519.html
[Git Daten]: https://www.patrickzahnd.ch/uploads/git-transport-v1.png
[Branch]:https://www.patrickzahnd.ch/uploads/gitflow.png 
[Was ist ein Branch]:https://git-scm.com/book/de/v1/Git-Branching-Was-ist-ein-Branch%3F
[Merge]:https://git-scm.com/figures/18333fig0316-tn.png
